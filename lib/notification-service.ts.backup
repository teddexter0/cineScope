import nodemailer from 'nodemailer'
import cron from 'node-cron'
import { PrismaClient } from '@prisma/client'
import { AIOrchestrator } from './ai-services'
import { tmdbService } from './tmdb'

const prisma = new PrismaClient()
const aiOrchestrator = new AIOrchestrator()

interface NotificationPreferences {
  newReleases: boolean
  weeklyDigest: boolean
  personalizedAlerts: boolean
  email: boolean
  push: boolean
  optimalTiming: boolean
}

class NotificationService {
  private transporter: nodemailer.Transporter

  constructor() {
    this.transporter = nodemailer.createTransporter({
      host: process.env.SMTP_HOST,
      port: parseInt(process.env.SMTP_PORT || '587'),
      secure: false,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    })

    this.initializeScheduledJobs()
  }

  // Initialize cron jobs for automated notifications
  private initializeScheduledJobs() {
    // Daily personalized recommendations (8 PM)
    cron.schedule('0 20 * * *', () => {
      this.sendDailyRecommendations()
    })

    // Weekly digest (Sunday 6 PM)
    cron.schedule('0 18 * * 0', () => {
      this.sendWeeklyDigest()
    })

    // Check for new releases (Daily at 10 AM)
    cron.schedule('0 10 * * *', () => {
      this.checkNewReleases()
    })

    // Personalized timing notifications
    cron.schedule('*/30 * * * *', () => { // Every 30 minutes
      this.sendOptimalTimingNotifications()
    })
  }

  // Send personalized daily recommendations
  async sendDailyRecommendations() {
    try {
      const users = await prisma.user.findMany({
        include: {
          preferences: true,
          onboardingData: true
        },
        where: {
          preferences: { isNot: null },
          onboardingData: { completed: true }
        }
      })

      for (const user of users) {
        await this.sendPersonalizedRecommendation(user.id, 'daily')
      }
    } catch (error) {
      console.error('Error sending daily recommendations:', error)
    }
  }

  // Send personalized recommendation to specific user
  async sendPersonalizedRecommendation(userId: string, context: string) {
    try {
      const user = await prisma.user.findUnique({
        where: { id: userId },
        include: {
          preferences: true,
          onboardingData: true,
          ratings: {
            include: { movie: true },
            orderBy: { createdAt: 'desc' },
            take: 5
          }
        }
      })

      if (!user?.preferences || !user.email) return

      // Get current time context
      const hour = new Date().getHours()
      const timeOfDay = hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening'
      
      // Generate AI recommendation
      const recommendation = await aiOrchestrator.generateRecommendations(
        userId,
        user.preferences.moodProfile as any,
        user.ratings.map(r => r.movie).filter(Boolean),
        `${context}_${timeOfDay}`
      )

      if (recommendation.movieIds.length === 0) return

      // Get movie details
      const movieId = recommendation.movieIds[0]
      const movie = await this.getOrFetchMovie(movieId)

      if (!movie) return

      // Generate personalized email content
      const emailContent = await this.generatePersonalizedEmail(user, movie, recommendation.reasoning)

      // Send email
      await this.transporter.sendMail({
        from: process.env.SMTP_USER,
        to: user.email,
        subject: emailContent.subject,
        html: emailContent.html
      })

      console.log(`ðŸ“§ Sent personalized recommendation to ${user.email}`)

    } catch (error) {
      console.error('Error sending personalized recommendation:', error)
    }
  }

  // Check for new releases that match user preferences
  async checkNewReleases() {
    try {
      const users = await prisma.user.findMany({
        include: { preferences: true },
        where: { preferences: { isNot: null } }
      })

      // Get upcoming movies from TMDB
      const upcomingMovies = await tmdbService.getUpcomingMovies()
      
      for (const user of users) {
        await this.checkUserNewReleases(user, upcomingMovies.results)
      }
    } catch (error) {
      console.error('Error checking new releases:', error)
    }
  }

  private async checkUserNewReleases(user: any, upcomingMovies: any[]) {
    if (!user.preferences?.genreWeights) return

    const userGenres = user.preferences.genreWeights as Record<string, number>
    const topGenres = Object.entries(userGenres)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([genre]) => genre)

    // Find movies matching user's top genres
    const matchingMovies = upcomingMovies.filter(movie => {
      return movie.genre_ids?.some((genreId: number) => {
        // You'd need to map TMDB genre IDs to names
        return topGenres.includes(this.getGenreName(genreId))
      })
    })

    if (matchingMovies.length > 0) {
      const topMatch = matchingMovies[0]
      await this.sendNewReleaseAlert(user, topMatch)
    }
  }

  // Send weekly digest
  async sendWeeklyDigest() {
    try {
      const users = await prisma.user.findMany({
        include: {
          preferences: true,
          ratings: {
            include: { movie: true },
            where: {
              createdAt: {
                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
              }
            }
          },
          interactions: {
            where: {
              createdAt: {
                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
              }
            }
          }
        }
      })

      for (const user of users) {
        await this.sendWeeklyDigestEmail(user)
      }
    } catch (error) {
      console.error('Error sending weekly digest:', error)
    }
  }

  // Send notifications at optimal times for each user
  async sendOptimalTimingNotifications() {
    try {
      const now = new Date()
      const currentHour = now.getHours()
      const currentMinute = now.getMinutes()
      const timeString = `${currentHour.toString().padStart(2, '0')}:${Math.floor(currentMinute/30)*30}`

      // Find users whose optimal notification time is now
      const users = await prisma.user.findMany({
        include: { preferences: true },
        where: {
          preferences: {
            watchingTimes: {
              path: ['optimalNotificationTime'],
              equals: timeString
            }
          }
        }
      })

      for (const user of users) {
        // Check if user has been active recently (don't spam inactive users)
        const recentActivity = await prisma.userInteraction.findFirst({
          where: {
            userId: user.id,
            createdAt: {
              gte: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000) // Last 3 days
            }
          }
        })

        if (recentActivity) {
          await this.sendPersonalizedRecommendation(user.id, 'optimal_timing')
        }
      }
    } catch (error) {
      console.error('Error sending optimal timing notifications:', error)
    }
  }

  // Generate personalized email content using AI
  private async generatePersonalizedEmail(user: any, movie: any, reasoning: string) {
    const name = user.name || user.username || 'Movie Lover'
    
    const subject = `ðŸŽ¬ ${name}, we found your next obsession!`
    
    const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Your CineScope Recommendation</title>
    </head>
    <body style="margin: 0; padding: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
      <div style="max-width: 600px; margin: 0 auto; background: white; border-radius: 16px; overflow: hidden; margin-top: 40px; margin-bottom: 40px; box-shadow: 0 20px 40px rgba(0,0,0,0.1);">
        
        <!-- Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px 30px; text-align: center; color: white;">
          <div style="width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center; font-size: 24px;">
            ðŸŽ¬
          </div>
          <h1 style="margin: 0; font-size: 28px; font-weight: bold;">Your AI Picked This Just For You!</h1>
          <p style="margin: 10px 0 0; opacity: 0.9; font-size: 16px;">Hi ${name}, based on your unique taste...</p>
        </div>

        <!-- Movie Card -->
        <div style="padding: 40px 30px;">
          <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 16px; overflow: hidden; margin-bottom: 30px;">
            ${movie.backdropPath ? `
            <img src="${tmdbService.getBackdropUrl(movie.backdropPath)}" alt="${movie.title}" style="width: 100%; height: 200px; object-fit: cover;">
            ` : ''}
            
            <div style="padding: 25px; color: white;">
              <h2 style="margin: 0 0 15px; font-size: 24px; font-weight: bold;">${movie.title}</h2>
              <p style="margin: 0 0 20px; opacity: 0.9; line-height: 1.6;">${movie.overview}</p>
              
              <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px;">
                ${movie.genres?.slice(0, 3).map((genre: any) => `
                  <span style="background: rgba(255,255,255,0.2); padding: 6px 12px; border-radius: 20px; font-size: 14px;">${genre.name}</span>
                `).join('') || ''}
              </div>
              
              <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 20px; margin-top: 20px;">
                <h3 style="margin: 0 0 10px; font-size: 18px;">ðŸ§  Why our AI chose this for you:</h3>
                <p style="margin: 0; opacity: 0.9; line-height: 1.6;">${reasoning}</p>
              </div>
            </div>
          </div>

          <!-- Call to Action -->
          <div style="text-align: center; margin-bottom: 30px;">
            <a href="${process.env.NEXTAUTH_URL}/dashboard" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-decoration: none; padding: 16px 32px; border-radius: 12px; font-weight: bold; font-size: 16px; box-shadow: 0 8px 20px rgba(102,126,234,0.3);">
              ðŸš€ View All My Recommendations
            </a>
          </div>

          <!-- Stats -->
          <div style="background: #f8f9ff; border-radius: 12px; padding: 25px; text-align: center;">
            <h3 style="margin: 0 0 20px; color: #333; font-size: 18px;">Your CineScope Stats</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
              <div>
                <div style="font-size: 24px; font-weight: bold; color: #667eea; margin-bottom: 5px;">95%</div>
                <div style="color: #666; font-size: 14px;">Match Rate</div>
              </div>
              <div>
                <div style="font-size: 24px; font-weight: bold; color: #f5576c; margin-bottom: 5px;">47</div>
                <div style="color: #666; font-size: 14px;">Discovered</div>
              </div>
              <div>
                <div style="font-size: 24px; font-weight: bold; color: #764ba2; margin-bottom: 5px;">12h</div>
                <div style="color: #666; font-size: 14px;">Time Saved</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Footer -->
        <div style="background: #f8f9ff; padding: 30px; text-align: center; border-top: 1px solid #e9ecef;">
          <p style="margin: 0 0 15px; color: #666; font-size: 14px;">
            Getting recommendations you don't love? 
            <a href="${process.env.NEXTAUTH_URL}/dashboard" style="color: #667eea; text-decoration: none;">Help us learn your taste better!</a>
          </p>
          <p style="margin: 0; color: #999; font-size: 12px;">
            You're receiving this because you signed up for personalized movie recommendations.
            <a href="#" style="color: #999; text-decoration: none;">Unsubscribe</a>
          </p>
        </div>
      </div>
    </body>
    </html>
    `

    return { subject, html }
  }

  private async sendNewReleaseAlert(user: any, movie: any) {
    if (!user.email) return

    const releaseDate = new Date(movie.release_date).toLocaleDateString()
    
    await this.transporter.sendMail({
      from: process.env.SMTP_USER,
      to: user.email,
      subject: `ðŸ†• New Release Alert: ${movie.title}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2 style="color: #333;">ðŸŽ¬ New Movie Alert!</h2>
          <h3>${movie.title}</h3>
          <p><strong>Release Date:</strong> ${releaseDate}</p>
          <p>${movie.overview}</p>
          <p style="background: #f0f8ff; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
            ðŸ’¡ <strong>Why you'll love it:</strong> Based on your preference for ${Object.keys(user.preferences?.genreWeights || {}).slice(0, 2).join(' and ')}, this movie is right up your alley!
          </p>
          <a href="${process.env.NEXTAUTH_URL}/dashboard" style="display: inline-block; background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin-top: 15px;">
            Add to My Watchlist
          </a>
        </div>
      `
    })
  }

  private async sendWeeklyDigestEmail(user: any) {
    if (!user.email) return

    const watchedCount = user.ratings?.length || 0
    const interactionCount = user.interactions?.length || 0
    
    await this.transporter.sendMail({
      from: process.env.SMTP_USER,
      to: user.email,
      subject: 'ðŸ“Š Your Weekly CineScope Digest',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2 style="color: #333;">ðŸ“Š Your Weekly Movie Journey</h2>
          <p>Hi ${user.name || user.username}!</p>
          
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin: 20px 0;">
            <h3 style="margin-top: 0;">This Week's Stats</h3>
            <ul style="list-style: none; padding: 0;">
              <li>ðŸŽ¬ Movies Rated: ${watchedCount}</li>
              <li>ðŸ‘† Interactions: ${interactionCount}</li>
              <li>ðŸŽ¯ Recommendations Accuracy: Getting better every day!</li>
            </ul>
          </div>
          
          <a href="${process.env.NEXTAUTH_URL}/dashboard" style="display: inline-block; background: #f5576c; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin-top: 15px;">
            Discover This Week's Picks
          </a>
        </div>
      `
    })
  }

  private async getOrFetchMovie(tmdbId: number) {
    let movie = await prisma.movie.findUnique({
      where: { tmdbId }
    })

    if (!movie) {
      try {
        const tmdbMovie = await tmdbService.getMovie(tmdbId)
        const movieData = tmdbService.formatMovieForDB(tmdbMovie)
        
        const aiMetadata = await aiOrchestrator.extractMovieMetadata(tmdbMovie.overview || '')
        
        movie = await prisma.movie.create({
          data: {
            ...movieData,
            themes: aiMetadata.themes,
            moodTags: aiMetadata.mood,
            complexity: aiMetadata.complexity
          }
        })
      } catch (error) {
        console.error('Error fetching movie:', error)
        return null
      }
    }

    return movie
  }

  private getGenreName(genreId: number): string {
    const genreMap: Record<number, string> = {
      28: 'Action',
      12: 'Adventure',
      16: 'Animation',
      35: 'Comedy',
      80: 'Crime',
      99: 'Documentary',
      18: 'Drama',
      10751: 'Family',
      14: 'Fantasy',
      36: 'History',
      27: 'Horror',
      10402: 'Music',
      9648: 'Mystery',
      10749: 'Romance',
      878: 'Science Fiction',
      10770: 'TV Movie',
      53: 'Thriller',
      10752: 'War',
      37: 'Western'
    }
    return genreMap[genreId] || 'Unknown'
  }
}

export const notificationService = new NotificationService()